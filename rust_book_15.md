
%Date%:20220521
%source%:https://doc.rust-jp.rs/book-ja/ch15-04-rc.html

## 概要

## 発見
### 15.4 Rc<T>は、参照カウント方式のスマートポインタ
* *例えば、グラフデータ構造では、 複数の辺が同じノードを指す可能性があり、概念的にそのノードはそれを指す全ての辺に所有されるわけです。 指す辺がなくならない限り、ノードは片付けられるべきではありません。*
  * 確かに. graph構造とかはモロRcだな. graphって言われると頻出じゃんって思うけど、実際Rcでちゃんとプログラム書いたことないのでまだまだ経験がたりてないということでしょうか.
* 例がcons listなのは最高
* *Rc::clone(&a)ではなく、a.clone()を呼ぶこともできますが、Rustのしきたりは、この場合Rc::cloneを使うことです*
  * これは自分でも気づいていたけど、docsに明示的に書かれててやっぱそうだよね、と.

### 15.5 RefCell<T>と内部可変性パターン
* *いかなる時も(以下の両方ではなく、)1つの可変参照かいくつもの不変参照のどちらかが可能になる, 参照は常に有効でなければならない。*
  * Rustの安全性を支える数少ない定理

### 循環参照は、メモリをリークすることもある
* *循環参照を回避する別の解決策は、ある参照は所有権を表現して他の参照はしないというようにデータ構造を再構成することです。*
  * ちょっとよく分からん
* *この関係を別の方法で捉えると、親ノードは子供を所有すべきです: 親ノードがドロップされたら、 子ノードもドロップされるべきなのです。ですが、子供は親を所有するべきではありません: 子ノードをドロップしても、親はまだ存在するべきです。弱い参照を使う場面ですね！* 
  * なるほど...
## 疑問

## その他
https://doc.rust-jp.rs/book-ja/ch15-04-rc.html
