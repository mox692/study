%Date%:20210221
%source%:https://hazm.at/mox/distributed-system/algorithm/transaction/raft/index.html

## 発見
### 2章
* あくまで、ログを複製するアルゴリズムであるという記述がなされてる
* ログが全てのnodeで同じになるようにする
* ログが同じであれば、nodeのstateは全て等しくなるはず
* 参加者が途中でdownしても、途中で復帰する可能性がある


### 5章
これまでの自分の認識と違っていた箇所を列挙する
* followerはclientからのreqをreaderにリダイレクトできるように、readerのIDを保持しているらしい (これは今の実装だとnode managerにやらしてる部分だわ...)
* 選挙の失敗という概念があるらしい
* *候補者またはリーダーがそのタームが期限切れであることを発見すると、それはすぐにフォロワーに戻る。*
* *サーバが期限切れのターム番号を含むリクエストを受信した場合、そのリクエストは拒否される。*
* *最高のパフォーマンスを得るために並列して RPC を発行する。*
  * これどうやって実装しよう...
* *多数のフォロワーが同時に候補者となる場合、投票が分散して候補者が過半数を獲得することができなくなる。*
  * 選挙が失敗するってこういうことか...
* *フォロワーがクラッシュしたり、動作が遅くなったり、ネットワークパケットが失われた場合、リーダーはすべてのフォロワーが最終的にすべてのログエントリを保存するまで (クライアントに応答した後でも) AppendEntries RPC を無制限に再実行する。*
  * なるほど.堂宇やって実装しようか
* *エントリが安全に複製されると (後述) リーダーがそのエントリをステートマシンに適用し、その実行結果をクライアントに返す。*
  * こういう順番らしい
* *Raft はコミットされたエントリは永続的であり、最終的には利用可能なすべてのステートマシンによって実行されることを保証する。*
  * 一度commitされたら覆ることはない、と言い換えられる？
* フォロワーはログエントリがコミットされたことを知ると、そのエントリをそのローカルステートマシンに (ログ順に) 適用する。
  * follwerからみると、ログ、commitの流れに関して下記の状態がありえそう
    * ログを保持している
    * 保持しているログのうち、commitされたという通知をreaderから受け取る
    * state machineにログを実行する
* *Raft では、リーダーはフォロワーのログにそれ自身の複製を強制することによって矛盾を処理する。つまり、フォロワーログの競合するエントリはリーダーのログエントリで上書きされる。*
  * なるhど、確かにこれは安全そう.
  * readerのlogに絶対的に合わせる

## 疑問

## その他
