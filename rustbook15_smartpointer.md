## スマートポインタ
https://doc.rust-jp.rs/book-ja/ch15-00-smart-pointers.html

## 15
*一方、スマートポインタは、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造です。 スマートポインタという概念は、Rustに特有のものではありません。スマートポインタは、C++に端を発し、 他の言語にも存在しています。Rustでは、標準ライブラリに定義された色々なスマートポインタが、 参照以上の機能を提供します。この章で探究する一つの例が、参照カウント方式のスマートポインタ型です。 このポインタのおかげでデータに複数の所有者を持たせることができます。 所有者の数を追いかけ、所有者がいなくなったらデータの片付けをしてくれるからです。*
* 参照とスマートポインタが比較されている
  * 参照は参照するだけ
  * 一方smartは所有することを意味する
* スマートポインタは、普通構造体で実装されている
* スマートポインタはdropとderefトレイトを実装している

### 感想
* 参照カウントは、マルチスレッドになった時に途端に複雑になりそう...

## 15.2
* deref traitを実装した型に対して参照外しを行うと、
```
assert_eq!(5, *y);
```
は、内部的には
```
assert_eq!(5, *(y.deref()));
```
に展開されている

* *derefメソッドが値への参照を返し、*(y.deref())のかっこの外にある普通の参照外しがそれでも必要になるのは、 所有権システムがあるからです。derefメソッドが値への参照ではなく値を直接返したら、値はselfから外にムーブされてしまいます。 今回もそうですが、参照外し演算子を使用するときはほとんどの場合、MyBox<T>の中の値の所有権を奪いたくはありません。*
  * 所有権の勘を高める.

* *関数やメソッドで暗黙的な参照外し型強制*
  * この部分は個人的にまあまあ興味深かった
  * コードを書くprogrammerからするとこの機能があった方がいいのはわかるけど、コンパイラ泣かせでは？ 
    * 例えば&strを引数にとる関数があって、その関数を呼び出すコードを&str以外の型を渡して書いた時、毎回derefで&strに行き着くかを捜査してるってことでしょ？
    * まあでもあまり頻繁には発生しないケースかな？ (derefしまくってる型を渡すってコードはそんなに書かなさそうではあるが)
  * *Derefトレイトが関係する型に定義されていると、コンパイラは、型を分析し必要なだけDeref::derefを使用して、 参照を得、引数の型と一致させます。Deref::derefが挿入される必要のある回数は、コンパイル時に解決されるので、 参照外し型強制を活用するための実行時の代償は何もありません。*
    * derefを呼ぶ回数がコンパイル時に決まるだけで、derefを呼ぶコスト自体は避けられないよね？
